a)i) Al eliminar las funciones, el tiempo de ejecucion es menor ya que no se esta
utilizando tiempo en usar funciones (direccionamientos indirectos, condiciones, etc)
Por ejemplo, con entrada n=16 el primer caso tarda 0.000076s y el segundo 0.000028s

 ii) Tarda menos tiempo ya que suceden menos "miss" en memoria cache.
 Usando el ejemplo anterior, tenemos 0.000028s en el primer caso y 0.000015s en el segundo

 b) En el primer caso, con N bajon UN bucle es mejor, pero con un N mas grande, CUATRO bucles son
mejores ya que, en el primer caso no hay tantas variables a almacenar por lo que no hay tantos fallos
de cache al hacerlo en UN bucle, sin embargo, al aumentar N aumentan las variables por lo que si se hace en 
UN bucle habran muchos errores de memorias, siendo mas eficiente hacer 4 bucles que usen menos variables cada uno

En el segundo caso pasa lo contrario, al tener 4 matrices (no repetidas como en el caso anterior), UN bucle tarda mas que TRES
bucles cuando N es bajo y viceversa cuando N es alto, ya que inicialmente es mas efiente almacenar
menos variables en mas bucles ya que el hacerlo en uno solo genera bastantes fallos de memoria, sin embargo, al aumentar N
se pierde la ventaja de los bucles con menos variables ya que, al aumentar significativamente el numero de las mismas,
se generan mas errores de cache, haciendo que UN bucle sea mas eficiente (lidia con muchas variables de todas formas).

El tercero es lo mismo amigo, fijate.


c) Tarda mas el que da vuelta la matriz

d) El c贸digo implementa la multiplicaci贸n de matrices cuadradas 



NN utilizando la t茅cnica de bloques de tama帽o 





BSBS para mejorar la localidad espacial y temporal en el acceso a memoria.

Funcionamiento del algoritmo
Almacenamiento en memoria

Se usan matrices en formato unidimensional, con acceso por 铆ndices.
A y B se inicializan en 1, mientras que C comienza en 0.
Multiplicaci贸n por bloques (matmulblks)

Se recorren las matrices en bloques de tama帽o 





BSBS.
Se realizan tres bucles externos (I, J, K) para recorrer los bloques.
Se utilizan tres bucles internos (i, j, k) para calcular la multiplicaci贸n dentro de cada bloque.

En general, la versi贸n por bloques es m谩s r谩pida cuando se elige un 


BS adecuado.

Para valores peque帽os de 

N, la diferencia no es tan notoria, pero a medida que 

N crece, la versi贸n por bloques es significativamente m谩s r谩pida debido a la mejor eficiencia de cach茅.
La versi贸n sin bloques realiza muchos accesos dispersos a memoria, mientras que la versi贸n con bloques aprovecha la localidad espacial, reduciendo el n煤mero de accesos a RAM (lo m谩s costoso en tiempo).

En arquitecturas modernas, un 


BS entre 16 y 64 suele ser 贸ptimo.
Si 


BS es demasiado grande, se desperdicia cach茅 y se pierde eficiencia.
Si 


BS es demasiado peque帽o, el overhead de los bucles reduce la ventaja del m茅todo.
